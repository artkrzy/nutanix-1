{"status":{},"contains_secrets":false,"product_version":"3.3.1","spec":{"description":"Provisions a Karbon K8s cluster and enables worker node addition and removal.","resources":{"client_attrs":{"1c2a7ea2_deployment":{"y":350,"x":1052}},"service_definition_list":[{"singleton":false,"action_list":[{"description":"System action for creating an application","type":"system","critical":false,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"PcGetProjectReference"},{"kind":"app_task","name":"PcCheckProjectQuota"},{"kind":"app_task","name":"KarbonCreateCluster"},{"kind":"app_task","name":"KarbonGetClusterHealth"},{"kind":"app_task","name":"KarbonGetClusterDetails"},{"kind":"app_task","name":"SendKubeconfig"},{"kind":"app_task","name":"UpdateVmProject"}],"name":"e1584237_dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"KarbonGetClusterHealth"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"KarbonGetClusterDetails"}},{"from_task_reference":{"kind":"app_task","name":"KarbonCreateCluster"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"KarbonGetClusterHealth"}},{"from_task_reference":{"kind":"app_task","name":"PcGetProjectReference"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"PcCheckProjectQuota"}},{"from_task_reference":{"kind":"app_task","name":"PcCheckProjectQuota"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"KarbonCreateCluster"}},{"from_task_reference":{"kind":"app_task","name":"KarbonGetClusterDetails"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"SendKubeconfig"}},{"from_task_reference":{"kind":"app_task","name":"KarbonGetClusterDetails"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"UpdateVmProject"}},{"from_task_reference":{"kind":"app_task","name":"PcGetProjectReference"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"UpdateVmProject"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PcGetProjectReference","attrs":{"exit_status":[],"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220111\n# task_name:    PcGetProjectReference\n# description:  Given a project name, get the project reference metadata section. \n#               This is then meant to be used to update a VM project reference to move \n#               that VM into the project.\n#               Using PCv3 API: https:\/\/www.nutanix.dev\/api_references\/prism-central-v3\/#\/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   project_reference (as json output)\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nproject_name = \"@@{calm_project_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_projects(api_server,username,secret,secure=False):\n    \"\"\"Retrieve the list of Projects from Prism Central.\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        \n    Returns:\n        A list of Projects (entities part of the json response).\n    \"\"\"\n    entities = []\n    #region prepare the api call\n    headers = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"\/api\/nutanix\/v3\/projects\/list\"\n    url = \"https:\/\/{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"POST\"\n    length = 200\n\n    # Compose the json payload\n    payload = {\n        \"kind\": \"project\",\n        \"offset\": 0,\n        \"length\": length\n    }\n    #endregion\n    while True:\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,payload,secure)\n\n        # deal with the result\/response\n        if resp.ok:\n            json_resp = json.loads(resp.content)\n            entities.extend(json_resp['entities'])\n            key = 'length'\n            if key in json_resp['metadata']:\n                if json_resp['metadata']['length'] == length:\n                    print(\"Processing results from {} to {} out of {}\".format(\n                        json_resp['metadata']['offset'], \n                        json_resp['metadata']['length']+json_resp['metadata']['offset'],\n                        json_resp['metadata']['total_matches']))\n                    payload = {\n                        \"kind\": \"project\",\n                        \"offset\": json_resp['metadata']['length'] + json_resp['metadata']['offset'] + 1,\n                        \"length\": length\n                    }\n                else:\n                    return entities\n                    break\n            else:\n                return entities\n                break\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n\n\ndef prism_get_project(api_server,username,secret,project_name,project_uuid=None,secure=False):\n    \"\"\"Returns from Prism Central the uuid and details of a given project name.\n       If a project_uuid is specified, it will skip retrieving all vms (faster).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        project_name: Name of the project.\n        project_uuid: Uuid of the project (optional).\n        \n    Returns:\n        A string containing the UUID of the Project (project_uuid) and the json content\n        of the project details (project_details)\n    \"\"\"\n    project_details = {}\n\n    if project_uuid is None:\n        #get the list vms from Prism\n        project_list = prism_get_projects(api_server,username,secret,secure)\n        for project in project_list:\n            if project['spec']['name'] == project_name:\n                project_uuid = project['metadata']['uuid']\n                project_details = project.copy()\n                break\n    else:\n        headers = {\n        'Content-Type': 'application\/json',\n        'Accept': 'application\/json'\n        }\n        api_server_port = \"9440\"\n        api_server_endpoint = \"\/api\/nutanix\/v3\/projects\/{0}\".format(project_uuid)\n        url = \"https:\/\/{}:{}{}\".format(\n            api_server,\n            api_server_port,\n            api_server_endpoint\n        )\n        method = \"GET\"\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,secure)\n        if resp.ok:\n            project_details = json.loads(resp.content)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n    return project_uuid, project_details\n\n#endregion functions\n\n\n#region main execution\nproject_uuid,project_details = prism_get_project(prism_central_ip,pc_user,pc_password,project_name)\nproject_reference = project_details['metadata']['project_reference']\nprint(\"project_reference={}\".format(json.dumps(project_reference)))\nexit(0)\n#endregion main execution\n","eval_variables":["project_reference"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PcCheckProjectQuota","attrs":{"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220111\n# task_name:    PcCheckProjectQuota\n# description:  Given a project name, check the project quota against provided resources. \n#               If there are not enough available resources in the quota, returns a failure code.\n#               Using PCv3 API: https:\/\/www.nutanix.dev\/api_references\/prism-central-v3\/#\/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   none\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nproject_reference = json.loads('@@{project_reference}@@')\nmaster_config = \"@@{master_config}@@\"\nworker_node_cpu_count = int(\"@@{worker_node_cpu}@@\")\nworker_node_vram_bytes = int(\"@@{worker_node_memory}@@\")*1024*1024*1024\nworker_node_storage_bytes = (int(\"@@{worker_node_disk_size}@@\")+40)*1024*1024*1024\nworker_node_qty = int(\"@@{worker_node_qty}@@\")\n\n#? master and etcd nodes configuration depends on master_config (Single Master, or Active-Passive\/Active-Active)\n#? worker nodes is based on user input and stored in worker_node_cpu, worker_node_memory, worker_node_disk_size, worker_node_qty\n#? for disk size, add +40GB for system disks for each node VM\nif master_config == \"Single Master\":\n    master_node_cpu_count = 2\n    master_node_vram_bytes = 4*1024*1024*1024\n    master_node_storage_bytes = (120+40)*1024*1024*1024\n    master_node_qty = 1\n    etcd_node_cpu_count = 4\n    etcd_node_vram_bytes = 8*1024*1024*1024\n    etcd_node_storage_bytes = (40+40)*1024*1024*1024\n    etcd_node_qty = 1\nelse:\n    master_node_cpu_count = 4\n    master_node_vram_bytes = 4*1024*1024*1024\n    master_node_storage_bytes = (120+40)*1024*1024*1024\n    master_node_qty = 2\n    etcd_node_cpu_count = 4\n    etcd_node_vram_bytes = 8*1024*1024*1024\n    etcd_node_storage_bytes = (40+40)*1024*1024*1024\n    etcd_node_qty = 3\n\n#worker node(s) + master node(s) + etcd node(s) \nrequired_vcpus_count = (int(worker_node_cpu_count) * int(worker_node_qty)) + (master_node_cpu_count * master_node_qty) +  (etcd_node_cpu_count * etcd_node_qty)\nrequired_vram_bytes = (int(worker_node_vram_bytes) * int(worker_node_qty)) + (master_node_vram_bytes * master_node_qty) +  (etcd_node_vram_bytes * etcd_node_qty)\nrequired_storage_bytes = (int(worker_node_storage_bytes) * int(worker_node_qty)) + (master_node_storage_bytes * master_node_qty) +  (etcd_node_storage_bytes * etcd_node_qty)\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_projects(api_server,username,secret,secure=False):\n    \"\"\"Retrieve the list of Projects from Prism Central.\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        \n    Returns:\n        A list of Projects (entities part of the json response).\n    \"\"\"\n    entities = []\n    #region prepare the api call\n    headers = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"\/api\/nutanix\/v3\/projects\/list\"\n    url = \"https:\/\/{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"POST\"\n    length = 200\n\n    # Compose the json payload\n    payload = {\n        \"kind\": \"project\",\n        \"offset\": 0,\n        \"length\": length\n    }\n    #endregion\n    while True:\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,payload,secure)\n\n        # deal with the result\/response\n        if resp.ok:\n            json_resp = json.loads(resp.content)\n            entities.extend(json_resp['entities'])\n            key = 'length'\n            if key in json_resp['metadata']:\n                if json_resp['metadata']['length'] == length:\n                    print(\"Processing results from {} to {} out of {}\".format(\n                        json_resp['metadata']['offset'], \n                        json_resp['metadata']['length']+json_resp['metadata']['offset'],\n                        json_resp['metadata']['total_matches']))\n                    payload = {\n                        \"kind\": \"project\",\n                        \"offset\": json_resp['metadata']['length'] + json_resp['metadata']['offset'] + 1,\n                        \"length\": length\n                    }\n                else:\n                    return entities\n                    break\n            else:\n                return entities\n                break\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n\n\ndef prism_get_project(api_server,username,secret,project_name=None,project_uuid=None,secure=False):\n    \"\"\"Returns from Prism Central the uuid and details of a given project name.\n       If a project_uuid is specified, it will skip retrieving all vms (faster).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        project_name: Name of the project.\n        project_uuid: Uuid of the project (optional).\n        \n    Returns:\n        A string containing the UUID of the Project (project_uuid) and the json content\n        of the project details (project_details)\n    \"\"\"\n    project_details = {}\n\n    if project_uuid is None:\n        #get the list vms from Prism\n        project_list = prism_get_projects(api_server,username,secret,secure)\n        for project in project_list:\n            if project['spec']['name'] == project_name:\n                project_uuid = project['metadata']['uuid']\n                project_details = project.copy()\n                break\n    else:\n        headers = {\n        'Content-Type': 'application\/json',\n        'Accept': 'application\/json'\n        }\n        api_server_port = \"9440\"\n        api_server_endpoint = \"\/api\/nutanix\/v3\/projects\/{0}\".format(project_uuid)\n        url = \"https:\/\/{}:{}{}\".format(\n            api_server,\n            api_server_port,\n            api_server_endpoint\n        )\n        method = \"GET\"\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,secure)\n        if resp.ok:\n            project_details = json.loads(resp.content)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n    return project_uuid, project_details\n\n#endregion functions\n\n\n#region main execution\n\nprint(\"Provisioning request required vCPUs: {}\".format(required_vcpus_count))\nprint(\"Provisioning request required memory GB: {}\".format(required_vram_bytes\/1024\/1024\/1024))\nprint(\"Provisioning request required storage GB: {}\".format(required_storage_bytes\/1024\/1024\/1024))\n\n\n#region get project quotas\nproject_uuid,project_details = prism_get_project(prism_central_ip,pc_user,pc_password,project_uuid=project_reference['uuid'])\n#get resource total allocated quota from the project definition\nproject_cpu_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'VCPUS']\nprint(\"Project vCPU quota: {}\".format(project_cpu_quota[0]))\nproject_memory_bytes_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'MEMORY']\nprint(\"Project memory GB quota: {}\".format(int(project_memory_bytes_quota[0])\/1024\/1024\/1024))\nproject_storage_bytes_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'STORAGE']\nprint(\"Project storage GB quota: {}\".format(int(project_storage_bytes_quota[0])\/1024\/1024\/1024))\n#endregion get project quotas\n\n#region get project allocated resources\n#retrieve list of project vms and their current resource allocation\n#region api call\nheaders = {\n        'Content-Type': 'application\/json',\n        'Accept': 'application\/json'\n}\napi_server_port = \"9440\"\napi_server_endpoint = \"\/api\/nutanix\/v3\/groups\"\nurl = \"https:\/\/{}:{}{}\".format(\n    prism_central_ip,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\npayload = {\n    \"entity_type\": \"mh_vm\",\n    \"group_member_count\": 500,\n    \"group_member_offset\": 0,\n    \"group_member_attributes\": [\n        {\n            \"attribute\": \"memory_size_bytes\"\n        },\n        {\n            \"attribute\": \"capacity_bytes\"\n        },\n        {\n            \"attribute\": \"num_vcpus\"\n        },\n        {\n            \"attribute\": \"project_reference\"\n        },\n        {\n            \"attribute\": \"project_name\"\n        }\n    ],\n    \"query_name\": \"prism:EBQueryModel\",\n    \"availability_zone_scope\": \"GLOBAL\",\n    \"filter_criteria\": \"(platform_type!=aws,platform_type==[no_val]);project_reference=in={}\".format(project_uuid)\n}\nprint(\"Making a {} API call to {}\".format(method, url))\nr = process_request(url,method,pc_user,pc_password,headers,payload)\n#endregion api call\n\n#compute total current resource allocation\nresp = json.loads(r.content)\n\n\nproject_cpu_allocated = 0\nproject_memory_bytes_allocated = 0\nproject_storage_bytes_allocated = 0\n\nif int(resp['filtered_entity_count']) > 0:\n    entities=[entities for entities in resp['group_results'][0]['entity_results']]\n    vm_data = [data['data'] for data in entities]\n\n    for vm in vm_data:\n        for values in vm:\n            if values['name'] == 'num_vcpus':\n                for value in values['values']:\n                    project_cpu_allocated = project_cpu_allocated + int(value['values'][0])\n            elif values['name'] == 'memory_size_bytes':\n                    for value in values['values']:\n                        project_memory_bytes_allocated = project_memory_bytes_allocated + int(value['values'][0])\n            elif values['name'] == 'capacity_bytes':\n                    for value in values['values']:\n                        project_storage_bytes_allocated = project_storage_bytes_allocated + int(value['values'][0])\n                \n    print(\"Project allocated vCPUs: {}\".format(project_cpu_allocated))\n    print(\"Project allocated memory GB: {}\".format(project_memory_bytes_allocated\/1024\/1024\/1024))\n    print(\"Project allocated storage GB: {}\".format(project_storage_bytes_allocated\/1024\/1024\/1024))\nelse:\n    print(\"Project allocated vCPUs: 0\")\n    print(\"Project allocated memory GB: 0\")\n    print(\"Project allocated storage GB: 0\")\n#endregion get project allocated resources\n\n#region figure out if request complies with quotas\n#compute resources available in the project (quota - allocated)\nproject_available_vcpus = int(project_cpu_quota[0]) - project_cpu_allocated\nprint(\"Project available vCPUs: {}\".format(project_available_vcpus))\nproject_available_memory_bytes = int(project_memory_bytes_quota[0]) - project_memory_bytes_allocated\nprint(\"Project available memory bytes: {}\".format(project_available_memory_bytes))\nproject_available_storage_bytes = int(project_storage_bytes_quota[0]) - project_storage_bytes_allocated\nprint(\"Project available storage bytes: {}\".format(project_available_storage_bytes))\n\n#determine if there are enough resource available to process the request\nif (project_available_vcpus - required_vcpus_count) <= 0:\n    print(\"There aren't enough resources left in the project quota to accomodate this request!\")\n    exit(1)\nelif (project_available_memory_bytes - required_vram_bytes) <= 0:\n    print(\"There aren't enough resources bytes left in the project quota to accomodate this request!\")\n    exit(1)\nelif (project_available_storage_bytes - required_storage_bytes) <= 0:\n    print(\"There aren't enough resources bytes left in the project quota to accomodate this request!\")\n    exit(1)\nelse:\n    print(\"Project resources quota can accomodate this request.\")\n    exit(0)\n#endregion figure out if request complies with quotas\n\n#endregion main execution\n","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"KarbonCreateCluster","attrs":{"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220107\n# task_name:    KarbonCreateCluster\n# description:  Deploys a Karbon K8s cluster. Using Karbon API: https:\/\/www.nutanix.dev\/api_references\/karbon\/#\/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   create_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\nstorage_class_user = \"@@{storage_class_user.username}@@\"\nstorage_class_user_password = \"@@{storage_class_user.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\n\nworker_node_memory = 1024 * int(\"@@{worker_node_memory}@@\")\nworker_node_disk = 1024 * int(\"@@{worker_node_disk_size}@@\")\nworker_node_cpu = int(\"@@{worker_node_cpu}@@\")\nworker_node_qty = int(\"@@{worker_node_qty}@@\")\n\ncluster_name = \"@@{cluster_name}@@\"\nworker_node_pool = \"@@{cluster_name}@@\" + \"-worker-node-pool\"\nmaster_node_pool = \"@@{cluster_name}@@\" + \"-master-node-pool\"\netcd_node_pool = \"@@{cluster_name}@@\" + \"-etcd-node-pool\"\nfile_system = \"ext4\"\nstorage_container_name = \"@@{storage_container_name}@@\"\nk8s_version = \"@@{k8s_version}@@\"\nimage_name = \"@@{image_name}@@\"\nmaster_config = \"@@{master_config}@@\"\n\npe_cluster_uuid = \"@@{pe_cluster_uuid}@@\"\nsubnet_uuid = \"@@{subnet_uuid}@@\"\n\npod_cidr_range = \"@@{pod_cidr_range}@@\"\nservice_cidr_range = \"@@{service_cidr_range}@@\"\nk8s_cni = \"@@{k8s_cni}@@\"\ncalico_cidr = \"@@{calico_cidr}@@\"\nmaster_vip = \"@@{master_vip}@@\"\nmaster_vip2 = \"@@{master_vip2}@@\"\nexternal_lb = \"@@{external_lb}@@\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=60\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"\/api\/nutanix\/v3\/tasks\/{0}\".format(task_uuid)\n    url = \"https:\/\/{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                exit(1)\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare the api call\nurl = \"https:\/\/{}:9440\/karbon\/v1\/k8s\/clusters\".format(prism_central_ip)\nheaders = {'Content-Type': 'application\/json', 'Accept': 'application\/json'}\nmethod = 'POST'\n#initial payload\npayload = {\n  \"cni_config\": {\n    \"node_cidr_mask_size\": 24,\n    \"pod_ipv4_cidr\": pod_cidr_range,\n    \"service_ipv4_cidr\": service_cidr_range\n  },\n  \"etcd_config\": {\n   \n  },\n  \"masters_config\": {\n    \n  },\n  \"metadata\": {\n    \"api_version\": \"v1.0.0\"\n  },\n  \"name\": cluster_name,\n  \"storage_class_config\": {\n    \"default_storage_class\": True,\n    \"name\": \"default-storageclass\",\n    \"reclaim_policy\": \"Delete\",\n    \"volumes_config\": {\n      \"file_system\": file_system,\n      \"flash_mode\": False,\n      \"password\": storage_class_user_password,\n      \"prism_element_cluster_uuid\": pe_cluster_uuid,\n      \"storage_container\": storage_container_name,\n      \"username\": storage_class_user\n    }\n  },\n  \"version\": k8s_version,\n  \"workers_config\": {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": worker_node_cpu,\n        \"disk_mib\": worker_node_disk,\n        \"memory_mib\": worker_node_memory,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": worker_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": worker_node_qty\n    }]\n  }\n}\n#adding cni specific configuration\nif (k8s_cni == \"Flannel\"):\n  print (\"Configuring Flannel CNI\")\n  payload['cni_config']['flannel_config'] = {\n    \"ip_pool_configs\": [{\n      \"cidr\": pod_cidr_range\n    }]   \n  }\nelse:\n  print (\"Configuring Calico CNI\")\n  payload['cni_config']['calico_config'] = {\n    \"ip_pool_configs\": [{\n      \"cidr\": calico_cidr\n    }]   \n  }\n#variations for master\/etcd pools and lb configuration\nif (master_config == \"Single Master\"):\n  print (\"Configuring Single Master\")\n  master_pool = {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 2,\n        \"disk_mib\": 122880,\n        \"memory_mib\": 4096,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": master_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 1\n    }],\n    \"single_master_config\": { \n      \"external_ipv4_address\": master_vip\n    }\n  }\n  payload['masters_config'] = master_pool  \n  etcd_pool = {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 40960,\n        \"memory_mib\": 8192,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": etcd_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 1\n    }]\n  }\n  payload['etcd_config'] = etcd_pool\nelif (master_config == \"Active-Passive\"):\n  print (\"Configuring Active-Passive Master\")\n  master_pool = { \n    \"active_passive_config\": {\n      \"external_ipv4_address\": master_vip\n    },\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 122880,\n        \"memory_mib\": 4096,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": master_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 2\n    }]\n  }\n  payload['masters_config'] = master_pool\n  etcd_pool = {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 40960,\n        \"memory_mib\": 8192,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": etcd_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 3\n    }]\n  }\n  payload['etcd_config'] = etcd_pool\nelse:\n  print (\"Configuring Active-Active LoadBalancer Master\")\n  master_pool = {\n    \"external_lb_config\": {\n      \"external_ipv4_address\": external_lb,\n      \"master_nodes_config\": [\n      {\n        \"ipv4_address\": master_vip,\n        \"node_pool_name\": cluster_name\n      },\n      {\n        \"ipv4_address\": master_vip2,\n        \"node_pool_name\": cluster_name\n      }\n    ]},\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 122880,\n        \"memory_mib\": 4096,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": master_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 2\n    }]\n  }\n  payload['masters_config'] = master_pool\n  etcd_pool = {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 40960,\n        \"memory_mib\": 8192,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": etcd_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 3\n    }]  \n  }\n  payload['etcd_config'] = etcd_pool\n#endregion prepare the api call\n\n\n#region make the api call\n#print(json.dumps(payload))\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Creation of task to create cluster was successful\")\nprint (json.loads(resp.content))\ncreate_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(create_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,create_task_uuid)\n\nexit(0)\n#endregion make the api call\n","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"KarbonGetClusterHealth","attrs":{"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220106\n# task_name:    KarbonGetClusterHealth\n# description:  Retrieves health status for a Karbon managed K8s cluster. \n#               Loops until health status can be retrieved or times out after 20 minutes.\n#               Using Karbon API: https:\/\/www.nutanix.dev\/api_references\/karbon\/#\/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   none\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n\n#region other variables\ntime_out = 20\n#endregion other variables\n\n\n#region prepare the api call\nurl = \"https:\/\/{}:9440\/karbon\/v1\/k8s\/clusters\/{}\/health\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application\/json', 'Accept': 'application\/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\ncount = 0\nwhile(count < time_out):\n    print(\"Making a GET request to {}\".format(url))\n    resp = requests.get(url, headers=headers, auth=(pc_user, pc_password), verify=False)\n    if resp.ok:\n        print (\"Successfully retrieved health status for the cluster\")\n        print(json.loads(resp.content))\n        exit(0)\n    elif (resp.status_code == 412):\n        print (\"Cluster Health: K8s cluster deployment not ready.  Sleeping for 60 seconds\")\n        count = count + 1\n        sleep(60)\n    else:\n        print (\"Could not retrieve the cluster health status\")\n        print(json.loads(resp.content))\n        exit(1)\n\nprint (\"Error: Operation Timeout after 20 mins\")\nexit(1)\n#endregion make the api call","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"KarbonGetClusterDetails","attrs":{"exit_status":[],"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220106\n# task_name:    KarbonGetClusterDetails\n# description:  Retrieves configuration information for a Karbon managed K8s cluster. \n#               Using Karbon API: https:\/\/www.nutanix.dev\/api_references\/karbon\/#\/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   kubeapi_server_ipv4_address,k8s_version,karbon_cluster_uuid,node_cidr_mask_size,pod_ipv4_cidr,service_ipv4_cidr\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n#region prepare the api call\nurl = \"https:\/\/{}:9440\/karbon\/v1\/k8s\/clusters\/{}\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application\/json', 'Accept': 'application\/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\nprint(\"Making a GET request to {}\".format(url))\nresp = process_request(url, method, pc_user, pc_password, headers)\n    \nprint (\"Successfully retrieved health status for the cluster\")\nprint(json.loads(resp.content))\n\n#* output vars defined here\nkubeapi_server_ipv4_address = resp.json()['kubeapi_server_ipv4_address']\nprint (\"kubeapi_server_ipv4_address={}\".format(kubeapi_server_ipv4_address))\nk8s_version = resp.json()['version']\nprint (\"k8s_version={}\".format(k8s_version))\nkarbon_cluster_uuid = resp.json()['uuid']\nprint (\"karbon_cluster_uuid={}\".format(karbon_cluster_uuid))\nnode_cidr_mask_size = resp.json()['cni_config']['node_cidr_mask_size']\nprint (\"node_cidr_mask_size={}\".format(node_cidr_mask_size))\npod_ipv4_cidr = resp.json()['cni_config']['pod_ipv4_cidr']\nprint (\"pod_ipv4_cidr={}\".format(pod_ipv4_cidr))\nservice_ipv4_cidr = resp.json()['cni_config']['service_ipv4_cidr']\nprint (\"service_ipv4_cidr={}\".format(service_ipv4_cidr))\n\nexit(0)\n#endregion make the api call","eval_variables":["kubeapi_server_ipv4_address","cluster_k8s_version"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"SendKubeconfig","attrs":{"type":"CALL_RUNBOOK","inarg_list":[],"runbook_reference":{"kind":"app_runbook","name":"55bdcacb_runbook"}},"timeout_secs":"0","type":"CALL_RUNBOOK","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"UpdateVmProject","attrs":{"type":"CALL_RUNBOOK","inarg_list":[],"runbook_reference":{"kind":"app_runbook","name":"1fece5ec_runbook"}},"timeout_secs":"0","type":"CALL_RUNBOOK","variable_list":[]}],"description":"","name":"82d0a3f5_runbook","main_task_local_reference":{"kind":"app_task","name":"e1584237_dag"},"variable_list":[]},"name":"action_create"},{"description":"System action for deleting an application. Deletes created VMs as well","type":"system","critical":false,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"KarbonDeleteCluster"}],"name":"d27d7cd9_dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"KarbonDeleteCluster","attrs":{"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220107\n# task_name:    KarbonDeleteCluster\n# description:  Deletes a Karbon K8s cluster. Using Karbon API: https:\/\/www.nutanix.dev\/api_references\/karbon\/#\/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   delete_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"\/api\/nutanix\/v3\/tasks\/{0}\".format(task_uuid)\n    url = \"https:\/\/{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                return task_status_details\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare the api call\nurl = \"https:\/\/{}:9440\/karbon\/v1\/k8s\/clusters\/{}\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application\/json', 'Accept': 'application\/json'}\nmethod = 'DELETE'\n#initial payload\npayload = {}\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Creation of task to delete cluster was successful\")\nprint(json.loads(resp.content))\ndelete_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(delete_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,delete_task_uuid)\n\nexit(0)\n#endregion make the api call","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"2cb579b6_runbook","main_task_local_reference":{"kind":"app_task","name":"d27d7cd9_dag"},"variable_list":[]},"name":"action_delete"},{"description":"System action for starting an application","type":"system","critical":false,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"21fd9350_dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]}],"description":"","name":"60814c0f_runbook","main_task_local_reference":{"kind":"app_task","name":"21fd9350_dag"},"variable_list":[]},"name":"action_start"},{"description":"System action for stopping an application","type":"system","critical":false,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"8eda2a42_dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]}],"description":"","name":"46f8c648_runbook","main_task_local_reference":{"kind":"app_task","name":"8eda2a42_dag"},"variable_list":[]},"name":"action_stop"},{"description":"System action for restarting an application","type":"system","critical":false,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"8703dd38_dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]}],"description":"","name":"91fdabc1_runbook","main_task_local_reference":{"kind":"app_task","name":"8703dd38_dag"},"variable_list":[]},"name":"action_restart"},{"description":"","type":"user","critical":false,"runbook":{"task_definition_list":[{"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"KarbonGetKubeconfig"},{"kind":"app_task","name":"SendMail"}],"name":"a1aa7936_dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"KarbonGetKubeconfig"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"SendMail"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"KarbonGetKubeconfig","attrs":{"exit_status":[],"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220106\n# task_name:    KarbonGetKubeConfig\n# description:  Retrieves kubeconfig for the given Karbon cluster. \n#               Using Karbon API: https:\/\/www.nutanix.dev\/api_references\/karbon\/#\/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   kubeconfig\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n#region prepare the api call\nurl = \"https:\/\/{}:9440\/karbon\/v1\/k8s\/clusters\/{}\/kubeconfig\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application\/json', 'Accept': 'application\/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers)\n#* output vars defined here\nkubeconfig = resp.json()['kube_config']\n\nencodedBytes = base64.b64encode(kubeconfig.encode(\"utf-8\"))\nencodedStr = str(encodedBytes)\nprint (\"kubeconfig={}\".format(encodedStr))\n\nexit(0)\n#endregion make the api call","eval_variables":["kubeconfig"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"SendMail","attrs":{"exit_status":[],"script":"#!\/bin\/bash\n\n# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0\/20210504 - cita-starter version\n# task_name:    SendMail\n# description:  sends an email notification to the Calm user including kubeconfig.               \n# output vars:  none\n# dependencies: none\n# endregion\n\nFrom=@@{email_sender}@@\nTo=@@{requester_email}@@\nSubject=\"Your Kubernetes kubeconfig\"\nAttachment=\"\/tmp\/@@{cluster_name}@@-kubeconfig\"\n\n#tee ${Attachment}\necho \"@@{kubeconfig}@@\" | base64 --decode > ${Attachment}\ngzip -f ${Attachment}\n\necho \"\nfrom email.message import EmailMessage\nfrom email.mime.multipart import MIMEMultipart\nimport smtplib\nimport os\nfrom email.mime.base import MIMEBase\nfrom email.mime.text import MIMEText\nfrom email import encoders\n\nserver = smtplib.SMTP(\"\\\"@@{smtp_server}@@\\\"\", 25)\n\nmsg = MIMEMultipart()\nBody = MIMEText('Hello,\\n\\nYou have requested a kubernetes cluster which was successfully deployed with version @@{cluster_k8s_version}@@.\\n\\nYou can connect to it using the following information:\\n\\tService type: Kubernetes Cluster\\n\\tK8s ip address: @@{kubeapi_server_ipv4_address}@@\\n\\tK8s cluster name: @@{cluster_name}@@\\n\\nYou can use the attached kubeconfig or the following kubectl plugin to log into your k8s cluster: https:\/\/github.com\/nutanix\/kubectl-karbon\\n\\nNote that the Prism Central IP address is @@{prism_central_ip}@@\\n\\nRegards,\\n\\nYour IT Team')\nmsg['Subject'] = '${Subject}'\nmsg['From'] = '${From}'\nmsg['To'] = '${To}'\nmsg.attach(Body)\n\npart = MIMEBase('application', 'octet-stream')\npart.set_payload(open('${Attachment}.gz', 'rb').read())\nencoders.encode_base64(part)\npart.add_header('Content-Disposition', 'attachment; filename=${Attachment}.gz')\nmsg.attach(part)\n\nserver.sendmail(msg['From'], [msg['To']], msg.as_string())\" | tee  ~\/send_notification\n\necho \"Sending user notification\"\n\npython3 ~\/send_notification\n\nrm ~\/send_notification\nrm \"${Attachment}.gz\"","script_type":"sh","type":"","command_line_args":"","login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"55bdcacb_runbook","main_task_local_reference":{"kind":"app_task","name":"a1aa7936_dag"},"variable_list":[]},"name":"SendKubeconfig"},{"description":"","type":"user","critical":false,"runbook":{"task_definition_list":[{"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"KarbonGetNodePoolsVmHostnames"},{"kind":"app_task","name":"PcUpdateVmProject"}],"name":"8d908151_dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"KarbonGetNodePoolsVmHostnames"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"PcUpdateVmProject"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"KarbonGetNodePoolsVmHostnames","attrs":{"exit_status":[],"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220107\n# task_name:    KarbonGetNodePoolsVmHostnames\n# description:  Given a Karbon cluster name, get all the vm node hostnames from all existing pools. \n#               Using PCv3 API: https:\/\/www.nutanix.dev\/api_references\/prism-central-v3\/#\/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   k8s_cluster_node_vms\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n\n#region prepare the api call\nurl = \"https:\/\/{}:9440\/karbon\/v1-alpha.1\/k8s\/clusters\/{}\/node-pools\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application\/json', 'Accept': 'application\/json'}\nmethod = 'GET'\n#initial payload\npayload = {}\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\n\ncontents = json.loads(resp.content)\nk8s_cluster_nodes = [item.get('nodes') for item in contents]\n\nk8s_cluster_node_vms=[]\nfor list in k8s_cluster_nodes:\n    for item in list:\n        k8s_cluster_node_vms.append(item['hostname'])\n\nprint (\"k8s_cluster_node_vms={}\".format(k8s_cluster_node_vms))\n\nexit(0)\n#endregion make the api call\n","eval_variables":["k8s_cluster_node_vms"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PcUpdateVmProject","attrs":{"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220107\n# task_name:    PcUpdateVmProject\n# description:  Given a list of vms and a project reference, update all those vms project with the new project reference.\n#               Using PCv3 API: https:\/\/www.nutanix.dev\/api_references\/prism-central-v3\/#\/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   none\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nproject_reference = json.loads('@@{project_reference}@@')\nvm_list = @@{k8s_cluster_node_vms}@@\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=60\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_vms(api_server,username,secret,secure=False):\n    \"\"\"Retrieve the list of VMs from Prism Central.\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        \n    Returns:\n        A list of VMs (entities part of the json response).\n    \"\"\"\n    entities = []\n    #region prepare the api call\n    headers = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"\/api\/nutanix\/v3\/vms\/list\"\n    url = \"https:\/\/{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"POST\"\n    length = 200\n\n    # Compose the json payload\n    payload = {\n        \"kind\": \"vm\",\n        \"offset\": 0,\n        \"length\": length\n    }\n    #endregion\n    while True:\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,payload,secure)\n\n        # deal with the result\/response\n        if resp.ok:\n            json_resp = json.loads(resp.content)\n            entities.extend(json_resp['entities'])\n            key = 'length'\n            if key in json_resp['metadata']:\n                if json_resp['metadata']['length'] == length:\n                    print(\"Processing results from {} to {} out of {}\".format(\n                        json_resp['metadata']['offset'], \n                        json_resp['metadata']['length']+json_resp['metadata']['offset'],\n                        json_resp['metadata']['total_matches']))\n                    payload = {\n                        \"kind\": \"vm\",\n                        \"offset\": json_resp['metadata']['length'] + json_resp['metadata']['offset'] + 1,\n                        \"length\": length\n                    }\n                else:\n                    return entities\n                    break\n            else:\n                return entities\n                break\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n\n#endregion functions\n\n#region main processing\n#* get all vms\nvms = prism_get_vms(prism_central_ip,pc_user,pc_password)\n\n#*foreach given vm in the list\nfor vm in vm_list:\n    #* figure out spec and metadata payload for that vm\n    for vm_object in vms:\n        if vm_object['spec']['name'] == vm:\n            vm_uuid = vm_object['metadata']['uuid']\n            vm_details = vm_object.copy()\n            break\n    vm_details.pop('status')\n    del vm_details['metadata']['entity_version']\n    #print(\"before: {}\".format(vm_details))\n    #* update project reference\n    if vm_details['metadata']['project_reference']['name'] != project_reference['name']:\n        vm_details['metadata']['project_reference'] = project_reference\n        print(\"updated metadata section: {}\".format(json.dumps(vm_details['metadata'])))\n        print(\"vm_uuid: {}\".format(vm_uuid))\n        \n        #* update vm with put\n        #region prepare the api call\n        url = \"https:\/\/{}:9440\/api\/nutanix\/v3\/vms\/{}\".format(prism_central_ip,vm_uuid)\n        headers = {'Content-Type': 'application\/json', 'Accept': 'application\/json'}\n        method = 'PUT'\n        #initial payload\n        payload = vm_details\n        #print(\"payload: {}\".format(json.dumps(payload)))\n        #endregion prepare the api call\n        #region make the api call\n        print(\"Making a {} API call to {}\".format(method, url))\n        resp = process_request(url, method, pc_user, pc_password, headers, payload)\n        print (\"Updated virtual machine {} with project {}\".format(vm_details['spec']['name'],project_reference['name']))\n        print(json.loads(resp.content))\n        #endregion make the api call\n    else:\n        print(\"Project for vm {} is already {}. Skipping.\".format(vm_details['spec']['name'],project_reference['name']))\n\nexit(0)\n\n\n#endregion main processing","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"1fece5ec_runbook","main_task_local_reference":{"kind":"app_task","name":"8d908151_dag"},"variable_list":[]},"name":"UpdateVmProject"}],"depends_on_list":[],"name":"ManagementService","port_list":[],"tier":"","variable_list":[{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"kubeapi_server_ipv4_address","value":"","label":"Kubernetes Management IP","attrs":{"type":""},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"cluster_k8s_version","value":"","label":"","attrs":{"type":""},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"SECRET","name":"kubeconfig","value":"","label":"","attrs":{"is_secret_modified":false,"secret_reference":{},"type":"SECRET"},"editables":{"value":false},"is_hidden":true,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"project_reference","value":"","label":"","attrs":{"type":""},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"k8s_cluster_node_vms","value":"","label":"","attrs":{"type":""},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}}],"description":""}],"substrate_definition_list":[{"description":"","action_list":[],"type":"EXISTING_VM","name":"ManagementLinuxVM","readiness_probe":{"connection_type":"SSH","retries":"5","connection_protocol":"","connection_port":22,"address":"@@{ip_address}@@","delay_secs":"60","disable_readiness_probe":false,"login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"os_type":"Linux","create_spec":{"type":"PROVISION_EXISTING_MACHINE","address":"10.48.111.42"},"variable_list":[]}],"credential_definition_list":[{"username":"sbourdeaud@gso.lab","description":"","type":"PASSWORD","secret":{"attrs":{"is_secret_modified":false,"secret_reference":{}}},"name":"prism_central","cred_class":"static"},{"username":"sbourdeaud@gso.lab","description":"","type":"PASSWORD","secret":{"attrs":{"is_secret_modified":false,"secret_reference":{}}},"name":"storage_class_user","cred_class":"static"},{"username":"centos","description":"","type":"KEY","secret":{"attrs":{"is_secret_modified":false,"secret_reference":{}}},"name":"linux","cred_class":"static"}],"package_definition_list":[{"description":"","action_list":[],"type":"DEB","service_local_reference_list":[{"kind":"app_service","name":"ManagementService"}],"name":"Package1","version":"","options":{"install_runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_package","name":"Package1"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"4df0b1dc_dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]}],"description":"","name":"96f39da5_runbook","main_task_local_reference":{"kind":"app_task","name":"4df0b1dc_dag"},"variable_list":[]},"type":"","uninstall_runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_package","name":"Package1"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"76a6411c_dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]}],"description":"","name":"2994e4d9_runbook","main_task_local_reference":{"kind":"app_task","name":"76a6411c_dag"},"variable_list":[]}},"variable_list":[]}],"app_profile_list":[{"deployment_create_list":[{"type":"GREENFIELD","action_list":[],"name":"1c2a7ea2_deployment","min_replicas":"1","default_replicas":"1","depends_on_list":[],"published_service_local_reference_list":[],"max_replicas":"1","package_local_reference_list":[{"kind":"app_package","name":"Package1"}],"substrate_local_reference":{"kind":"app_substrate","name":"ManagementLinuxVM"},"variable_list":[],"description":""}],"environment_reference_list":["bc51742f-80e6-6611-05da-41f55ae0aaef"],"patch_list":[],"description":"","action_list":[{"description":"","type":"user","critical":false,"runbook":{"task_definition_list":[{"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"PcCheckProjectQuota"},{"kind":"app_task","name":"KarbonAddWorkerNode"},{"kind":"app_task","name":"UpdateVmProject"}],"name":"6f43296c_dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"PcCheckProjectQuota"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"KarbonAddWorkerNode"}},{"from_task_reference":{"kind":"app_task","name":"KarbonAddWorkerNode"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"UpdateVmProject"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PcCheckProjectQuota","attrs":{"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220111\n# task_name:    PcCheckProjectQuota\n# description:  Given a project name, check the project quota against provided resources. \n#               If there are not enough available resources in the quota, returns a failure code.\n#               Using PCv3 API: https:\/\/www.nutanix.dev\/api_references\/prism-central-v3\/#\/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   none\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nproject_reference = json.loads('@@{project_reference}@@')\nworker_node_cpu_count = int(\"@@{worker_node_cpu}@@\")\nworker_node_vram_bytes = int(\"@@{worker_node_memory}@@\")*1024*1024*1024\nworker_node_storage_bytes = (int(\"@@{worker_node_disk_size}@@\")+40)*1024*1024*1024\nworker_node_qty = int(\"@@{add_worker_node_count}@@\")\n\n\n\n#worker node(s) + master node(s) + etcd node(s) \nrequired_vcpus_count = (int(worker_node_cpu_count) * int(worker_node_qty))\nrequired_vram_bytes = (int(worker_node_vram_bytes) * int(worker_node_qty))\nrequired_storage_bytes = (int(worker_node_storage_bytes) * int(worker_node_qty))\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_projects(api_server,username,secret,secure=False):\n    \"\"\"Retrieve the list of Projects from Prism Central.\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        \n    Returns:\n        A list of Projects (entities part of the json response).\n    \"\"\"\n    entities = []\n    #region prepare the api call\n    headers = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"\/api\/nutanix\/v3\/projects\/list\"\n    url = \"https:\/\/{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"POST\"\n    length = 200\n\n    # Compose the json payload\n    payload = {\n        \"kind\": \"project\",\n        \"offset\": 0,\n        \"length\": length\n    }\n    #endregion\n    while True:\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,payload,secure)\n\n        # deal with the result\/response\n        if resp.ok:\n            json_resp = json.loads(resp.content)\n            entities.extend(json_resp['entities'])\n            key = 'length'\n            if key in json_resp['metadata']:\n                if json_resp['metadata']['length'] == length:\n                    print(\"Processing results from {} to {} out of {}\".format(\n                        json_resp['metadata']['offset'], \n                        json_resp['metadata']['length']+json_resp['metadata']['offset'],\n                        json_resp['metadata']['total_matches']))\n                    payload = {\n                        \"kind\": \"project\",\n                        \"offset\": json_resp['metadata']['length'] + json_resp['metadata']['offset'] + 1,\n                        \"length\": length\n                    }\n                else:\n                    return entities\n                    break\n            else:\n                return entities\n                break\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n\n\ndef prism_get_project(api_server,username,secret,project_name=None,project_uuid=None,secure=False):\n    \"\"\"Returns from Prism Central the uuid and details of a given project name.\n       If a project_uuid is specified, it will skip retrieving all vms (faster).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        project_name: Name of the project.\n        project_uuid: Uuid of the project (optional).\n        \n    Returns:\n        A string containing the UUID of the Project (project_uuid) and the json content\n        of the project details (project_details)\n    \"\"\"\n    project_details = {}\n\n    if project_uuid is None:\n        #get the list vms from Prism\n        project_list = prism_get_projects(api_server,username,secret,secure)\n        for project in project_list:\n            if project['spec']['name'] == project_name:\n                project_uuid = project['metadata']['uuid']\n                project_details = project.copy()\n                break\n    else:\n        headers = {\n        'Content-Type': 'application\/json',\n        'Accept': 'application\/json'\n        }\n        api_server_port = \"9440\"\n        api_server_endpoint = \"\/api\/nutanix\/v3\/projects\/{0}\".format(project_uuid)\n        url = \"https:\/\/{}:{}{}\".format(\n            api_server,\n            api_server_port,\n            api_server_endpoint\n        )\n        method = \"GET\"\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,secure)\n        if resp.ok:\n            project_details = json.loads(resp.content)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n    return project_uuid, project_details\n\n#endregion functions\n\n\n#region main execution\n\nprint(\"Provisioning request required vCPUs: {}\".format(required_vcpus_count))\nprint(\"Provisioning request required memory GB: {}\".format(required_vram_bytes\/1024\/1024\/1024))\nprint(\"Provisioning request required storage GB: {}\".format(required_storage_bytes\/1024\/1024\/1024))\n\n\n#region get project quotas\nproject_uuid,project_details = prism_get_project(prism_central_ip,pc_user,pc_password,project_uuid=project_reference['uuid'])\n#get resource total allocated quota from the project definition\nproject_cpu_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'VCPUS']\nprint(\"Project vCPU quota: {}\".format(project_cpu_quota[0]))\nproject_memory_bytes_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'MEMORY']\nprint(\"Project memory GB quota: {}\".format(int(project_memory_bytes_quota[0])\/1024\/1024\/1024))\nproject_storage_bytes_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'STORAGE']\nprint(\"Project storage GB quota: {}\".format(int(project_storage_bytes_quota[0])\/1024\/1024\/1024))\n#endregion get project quotas\n\n#region get project allocated resources\n#retrieve list of project vms and their current resource allocation\n#region api call\nheaders = {\n        'Content-Type': 'application\/json',\n        'Accept': 'application\/json'\n}\napi_server_port = \"9440\"\napi_server_endpoint = \"\/api\/nutanix\/v3\/groups\"\nurl = \"https:\/\/{}:{}{}\".format(\n    prism_central_ip,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\npayload = {\n    \"entity_type\": \"mh_vm\",\n    \"group_member_count\": 500,\n    \"group_member_offset\": 0,\n    \"group_member_attributes\": [\n        {\n            \"attribute\": \"memory_size_bytes\"\n        },\n        {\n            \"attribute\": \"capacity_bytes\"\n        },\n        {\n            \"attribute\": \"num_vcpus\"\n        },\n        {\n            \"attribute\": \"project_reference\"\n        },\n        {\n            \"attribute\": \"project_name\"\n        }\n    ],\n    \"query_name\": \"prism:EBQueryModel\",\n    \"availability_zone_scope\": \"GLOBAL\",\n    \"filter_criteria\": \"(platform_type!=aws,platform_type==[no_val]);project_reference=in={}\".format(project_uuid)\n}\nprint(\"Making a {} API call to {}\".format(method, url))\nr = process_request(url,method,pc_user,pc_password,headers,payload)\n#endregion api call\n\n#compute total current resource allocation\nresp = json.loads(r.content)\n\n\nproject_cpu_allocated = 0\nproject_memory_bytes_allocated = 0\nproject_storage_bytes_allocated = 0\n\nif int(resp['filtered_entity_count']) > 0:\n    entities=[entities for entities in resp['group_results'][0]['entity_results']]\n    vm_data = [data['data'] for data in entities]\n\n    for vm in vm_data:\n        for values in vm:\n            if values['name'] == 'num_vcpus':\n                for value in values['values']:\n                    project_cpu_allocated = project_cpu_allocated + int(value['values'][0])\n            elif values['name'] == 'memory_size_bytes':\n                    for value in values['values']:\n                        project_memory_bytes_allocated = project_memory_bytes_allocated + int(value['values'][0])\n            elif values['name'] == 'capacity_bytes':\n                    for value in values['values']:\n                        project_storage_bytes_allocated = project_storage_bytes_allocated + int(value['values'][0])\n                \n    print(\"Project allocated vCPUs: {}\".format(project_cpu_allocated))\n    print(\"Project allocated memory GB: {}\".format(project_memory_bytes_allocated\/1024\/1024\/1024))\n    print(\"Project allocated storage GB: {}\".format(project_storage_bytes_allocated\/1024\/1024\/1024))\nelse:\n    print(\"Project allocated vCPUs: 0\")\n    print(\"Project allocated memory GB: 0\")\n    print(\"Project allocated storage GB: 0\")\n#endregion get project allocated resources\n\n#region figure out if request complies with quotas\n#compute resources available in the project (quota - allocated)\nproject_available_vcpus = int(project_cpu_quota[0]) - project_cpu_allocated\nprint(\"Project available vCPUs: {}\".format(project_available_vcpus))\nproject_available_memory_bytes = int(project_memory_bytes_quota[0]) - project_memory_bytes_allocated\nprint(\"Project available memory bytes: {}\".format(project_available_memory_bytes))\nproject_available_storage_bytes = int(project_storage_bytes_quota[0]) - project_storage_bytes_allocated\nprint(\"Project available storage bytes: {}\".format(project_available_storage_bytes))\n\n#determine if there are enough resource available to process the request\nif (project_available_vcpus - required_vcpus_count) <= 0:\n    print(\"There aren't enough resources left in the project quota to accomodate this request!\")\n    exit(1)\nelif (project_available_memory_bytes - required_vram_bytes) <= 0:\n    print(\"There aren't enough resources bytes left in the project quota to accomodate this request!\")\n    exit(1)\nelif (project_available_storage_bytes - required_storage_bytes) <= 0:\n    print(\"There aren't enough resources bytes left in the project quota to accomodate this request!\")\n    exit(1)\nelse:\n    print(\"Project resources quota can accomodate this request.\")\n    exit(0)\n#endregion figure out if request complies with quotas\n\n#endregion main execution\n\n","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"KarbonAddWorkerNode","attrs":{"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220107\n# task_name:    KarbonAddWorkerNode\n# description:  Adds worker node(s) to an existing Karbon managed k8s cluster. Using Karbon API: https:\/\/www.nutanix.dev\/api_references\/karbon\/#\/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   add_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nadd_worker_node_count = int(\"@@{add_worker_node_count}@@\")\ncluster_name = \"@@{cluster_name}@@\"\nworker_node_pool = \"@@{cluster_name}@@\" + \"-worker-node-pool\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=60\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"\/api\/nutanix\/v3\/tasks\/{0}\".format(task_uuid)\n    url = \"https:\/\/{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                exit(1)\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare api call\nheaders = {'Content-Type': 'application\/json', 'Accept': 'application\/json'}\npayload = {\n  \"count\": add_worker_node_count\n}\nmethod = 'POST'\nurl = \"https:\/\/{}:9440\/karbon\/v1-alpha.1\/k8s\/clusters\/{}\/node-pools\/{}\/add-nodes\".format(\n    prism_central_ip,\n    cluster_name,\n    worker_node_pool,\n)\n#endregion prepare api call\n\n\n#region make api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Creation of task to add Worker Node was successful\")\nprint(json.loads(resp.content))\nadd_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(add_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,add_task_uuid)\n\nexit(0)\n#endregion make api call","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"UpdateVmProject","attrs":{"type":"CALL_RUNBOOK","inarg_list":[],"runbook_reference":{"kind":"app_runbook","name":"1fece5ec_runbook"}},"timeout_secs":"0","type":"CALL_RUNBOOK","variable_list":[]}],"description":"","name":"876ef50a_runbook","main_task_local_reference":{"kind":"app_task","name":"6f43296c_dag"},"variable_list":[{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"add_worker_node_count","value":"1","label":"Nb of worker nodes to add","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}}]},"name":"Add Worker Node"},{"description":"","type":"user","critical":false,"runbook":{"task_definition_list":[{"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"KarbonRemoveWorkerNode"}],"name":"569dfdac_dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"KarbonRemoveWorkerNode","attrs":{"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220107\n# task_name:    KarbonRemoveWorkerNode\n# description:  Removes worker node(s) from an existing Karbon managed k8s cluster. Using Karbon API: https:\/\/www.nutanix.dev\/api_references\/karbon\/#\/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   remove_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nremove_worker_node_count = int(\"@@{remove_worker_node_count}@@\")\ncluster_name = \"@@{cluster_name}@@\"\nworker_node_pool = \"@@{cluster_name}@@\" + \"-worker-node-pool\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=60\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"\/api\/nutanix\/v3\/tasks\/{0}\".format(task_uuid)\n    url = \"https:\/\/{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                return task_status_details\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare api call\nheaders = {'Content-Type': 'application\/json', 'Accept': 'application\/json'}\npayload = {\n  \"count\": remove_worker_node_count\n}\nmethod = 'POST'\nurl = \"https:\/\/{}:9440\/karbon\/v1-alpha.1\/k8s\/clusters\/{}\/node-pools\/{}\/remove-nodes\".format(\n    prism_central_ip,\n    cluster_name,\n    worker_node_pool,\n)\n#endregion prepapre api call\n\n\n#region make api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Creation of task to remove Worker Node was successful\")\nprint(json.loads(resp.content))\nremove_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(remove_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,remove_task_uuid)\n\nexit(0)\n#endregion make api call","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"bd846b3b_runbook","main_task_local_reference":{"kind":"app_task","name":"569dfdac_dag"},"variable_list":[{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"remove_worker_node_count","value":"1","label":"Nb of worker nodes to remove","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}}]},"name":"Remove Worker Node"},{"description":"","type":"user","critical":false,"runbook":{"task_definition_list":[{"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"SendKubeconfig"}],"name":"548dfee9_dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"ManagementService"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"SendKubeconfig","attrs":{"type":"CALL_RUNBOOK","inarg_list":[],"runbook_reference":{"kind":"app_runbook","name":"55bdcacb_runbook"}},"timeout_secs":"0","type":"CALL_RUNBOOK","variable_list":[]}],"description":"","name":"124dab53_runbook","main_task_local_reference":{"kind":"app_task","name":"548dfee9_dag"},"variable_list":[{"regex":{"should_validate":true,"value":"(?:[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+\/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])"},"val_type":"STRING","is_mandatory":true,"description":"The kubeconfig file will be sent to this email address.","data_type":"BASE","type":"LOCAL","name":"email_address","value":"stephane.bourdeaud@nutanix.com","label":"Your email address","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}}]},"name":"Get kubeconfig file"}],"name":"Default","restore_config_list":[],"snapshot_config_list":[],"variable_list":[{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"prism_central_ip","value":"10.48.108.12","label":"","attrs":{"type":""},"editables":{"value":false},"is_hidden":true,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"smtp_server","value":"10.40.64.35","label":"","attrs":{"type":""},"editables":{"value":false},"is_hidden":true,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"email_sender","value":"stephane.bourdeaud@nutanix.com","label":"","attrs":{"type":""},"editables":{"value":false},"is_hidden":true,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"UUID of the AHV managed network used to deploy this cluster.","data_type":"BASE","type":"LOCAL","name":"subnet_uuid","value":"7c19b244-bcc7-4186-9f09-84db45dec57f","label":"","attrs":{"type":""},"editables":{"value":false},"is_hidden":true,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"UUID of the AHV cluster used to deploy this cluster.","data_type":"BASE","type":"LOCAL","name":"pe_cluster_uuid","value":"00058163-33b2-4359-0000-0000000167e4","label":"","attrs":{"type":""},"editables":{"value":false},"is_hidden":true,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"Name of the storage container used to provision k8s nodes and their vdisks.","data_type":"BASE","type":"LOCAL","name":"storage_container_name","value":"default-container-92132","label":"","attrs":{"type":""},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"Version of the host OS image used to provision k8s nodes by Karbon.","data_type":"BASE","type":"LOCAL","name":"image_name","value":"ntnx-1.0","label":"","attrs":{"type":""},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":true,"value":"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\\/(3[0-2]|[1-2][0-9]|[0-9]))$"},"val_type":"STRING","is_mandatory":false,"description":"This is the IPv4 CIDR range that will be used for the overlay network used by the pods.\nThe default is 172.20.0.0\/16. This can be the same for multiple different k8s clusters if pods from different clusters don't need to talk to each other directly.\nThis is only used if your selected Calico as the CNI.","data_type":"BASE","type":"LOCAL","name":"calico_cidr","value":"172.20.0.0\/16","label":"Calico CIDR Range","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":true,"value":"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\\/(3[0-2]|[1-2][0-9]|[0-9]))$"},"val_type":"STRING","is_mandatory":false,"description":"Required for Active-Active setups.","data_type":"BASE","type":"LOCAL","name":"external_lb","value":"","label":"External Load Balancer IP address","attrs":{"type":""},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":true,"value":"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\\/(3[0-2]|[1-2][0-9]|[0-9]))$"},"val_type":"STRING","is_mandatory":false,"description":"Only required for Active-Active setups.","data_type":"BASE","type":"LOCAL","name":"master_vip2","value":"","label":"Other Kubernetes VIP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":true,"value":"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$"},"val_type":"STRING","is_mandatory":false,"description":"Only required for Active-Passive and Active-Active setups.","data_type":"BASE","type":"LOCAL","name":"master_vip","value":"","label":"Kubernetes Cluster VIP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":true,"value":"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\\/(3[0-2]|[1-2][0-9]|[0-9]))$"},"val_type":"STRING","is_mandatory":false,"description":"This is the IPv4 CIDR range that will be used for the overlay network used by the pods.\nThe default is 172.20.0.0\/16. This can be the same for multiple different k8s clusters if pods from different clusters don't need to talk to each other directly.","data_type":"BASE","type":"LOCAL","name":"pod_cidr_range","value":"172.20.0.0\/16","label":"Pod CIDR Range","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":true,"value":"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\\/(3[0-2]|[1-2][0-9]|[0-9]))$"},"val_type":"STRING","is_mandatory":false,"description":"This is the IPv4 CIDR range that will be used for the service overlay network between the k8s nodes.\nThe default is 172.19.0.0\/16. This can be the same for multiple different k8s clusters.","data_type":"BASE","type":"LOCAL","name":"service_cidr_range","value":"172.19.0.0\/16","label":"Service CIDR Range","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"Quantity of worker nodes in the k8s cluster.\nDefault is the minimum of 1.","data_type":"BASE","type":"LOCAL","name":"worker_node_qty","value":"1","label":"Qty of Worker Nodes","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"Size (in GiB) of vDisk for each worker node.\nDefault is a minimum of 120 GiB.","data_type":"BASE","type":"LOCAL","name":"worker_node_disk_size","value":"120","label":"Worker Nodes vDisk GiB","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"Quantity (in GiB) of vRAM for each worker node.\nDefault is a minimum of 8 GiB.","data_type":"BASE","type":"LOCAL","name":"worker_node_memory","value":"8","label":"Worker Nodes vRAM GiB","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"Number of vCPUs for each worker nodes.\nDefault is a minimum of 8 vCPUs.","data_type":"BASE","type":"LOCAL","name":"worker_node_cpu","value":"8","label":"Worker Nodes vCPU Qty","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"k8s_cni","value":"Flannel","label":"Kubernetes CNI","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["Flannel","Calico"]}},{"val_type":"STRING","is_mandatory":true,"description":"Single Master: for non-production environments\nActive-Passive: for production environments without an external load balancer\nActive-Active: for production environments with a pre-configured external load balancer","data_type":"BASE","type":"LOCAL","name":"master_config","value":"Single Master","label":"Master node configuration","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["Single Master","Active-Passive","Active-Active"]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"k8s_version","value":"1.20.9-0","label":"Kubernetes version","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["1.20.9-0","1.19.13-0","1.18.20-0","1.17.13-0"]}},{"regex":{"should_validate":true,"value":"^((?!_).)*$"},"val_type":"STRING","is_mandatory":true,"description":"This is the name that will be displayed in the Karbon cluster manager.  It cannot contain any underscore (_) character.","data_type":"BASE","type":"LOCAL","name":"cluster_name","value":"karbon-test-cluster","label":"Kubernetes Cluster Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":true,"value":"(?:[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+\/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])"},"val_type":"STRING","is_mandatory":true,"description":"This will be used to send you information about the provisioned k8s cluster.","data_type":"BASE","type":"LOCAL","name":"requester_email","value":"stephane.bourdeaud@nutanix.com","label":"Your email address","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}}]}],"published_service_definition_list":[],"default_credential_local_reference":{"kind":"app_credential","name":"prism_central"},"type":"USER"},"name":"karbon-cluster-enhanced"},"api_version":"3.0","metadata":{"last_update_time":"1642080614384816","kind":"blueprint","spec_version":70,"creation_time":"1641483440571145","name":"karbon-cluster-enhanced"}}