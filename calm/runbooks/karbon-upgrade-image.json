{"status":{},"contains_secrets":false,"product_version":"3.3.1","spec":{"description":"Sends a request to upgrade a k8s cluster based on its name and the desired k8s version.","resources":{"endpoints_information":[],"endpoint_definition_list":[],"client_attrs":{},"credential_definition_list":[{"username":"sbourdeaud@gso.lab","description":"","type":"PASSWORD","secret":{"attrs":{"is_secret_modified":false,"secret_reference":{}}},"name":"prism_central","cred_class":"static"}],"runbook":{"task_definition_list":[{"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"KarbonGetClusterDetails"},{"kind":"app_task","name":"KarbonGetImageUuid"},{"kind":"app_task","name":"KarbonUpgradeHosts"}],"name":"70f463a2_dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"KarbonGetClusterDetails"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"KarbonGetImageUuid"}},{"from_task_reference":{"kind":"app_task","name":"KarbonGetImageUuid"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"KarbonUpgradeHosts"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"KarbonGetClusterDetails","attrs":{"exit_status":[],"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220106\n# task_name:    KarbonGetClusterDetails\n# description:  Retrieves configuration information for a Karbon managed K8s cluster. \n#               Using Karbon API: https:\/\/www.nutanix.dev\/api_references\/karbon\/#\/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   kubeapi_server_ipv4_address,k8s_version,karbon_cluster_uuid,node_cidr_mask_size,pod_ipv4_cidr,service_ipv4_cidr\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n#region prepare the api call\nurl = \"https:\/\/{}:9440\/karbon\/v1\/k8s\/clusters\/{}\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application\/json', 'Accept': 'application\/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\nprint(\"Making a GET request to {}\".format(url))\nresp = process_request(url, method, pc_user, pc_password, headers)\n    \nprint (\"Successfully retrieved health status for the cluster\")\nprint(json.loads(resp.content))\n\n#* output vars defined here\nkubeapi_server_ipv4_address = resp.json()['kubeapi_server_ipv4_address']\nprint (\"kubeapi_server_ipv4_address={}\".format(kubeapi_server_ipv4_address))\nk8s_version = resp.json()['version']\nprint (\"k8s_version={}\".format(k8s_version))\nkarbon_cluster_uuid = resp.json()['uuid']\nprint (\"karbon_cluster_uuid={}\".format(karbon_cluster_uuid))\nnode_cidr_mask_size = resp.json()['cni_config']['node_cidr_mask_size']\nprint (\"node_cidr_mask_size={}\".format(node_cidr_mask_size))\npod_ipv4_cidr = resp.json()['cni_config']['pod_ipv4_cidr']\nprint (\"pod_ipv4_cidr={}\".format(pod_ipv4_cidr))\nservice_ipv4_cidr = resp.json()['cni_config']['service_ipv4_cidr']\nprint (\"service_ipv4_cidr={}\".format(service_ipv4_cidr))\n\nexit(0)\n#endregion make the api call","eval_variables":["karbon_cluster_uuid"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"KarbonGetImageUuid","attrs":{"exit_status":[],"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220107\n# task_name:    KarbonGetImageUuid\n# description:  Gets the uuid of the specified host image version. \n#               Using Karbon API: https:\/\/www.nutanix.dev\/api_references\/karbon\/#\/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   image_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ntarget_image_version = \"@@{target_image_version}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n#region prepare the api call\nurl = \"https:\/\/{}:9440\/karbon\/acs\/image\/list\".format(prism_central_ip)\nheaders = {'Content-Type': 'application\/json', 'Accept': 'application\/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers)\n#* output vars defined here\nimages = json.loads(resp.content)\n\nfor image in images:\n    if image['version'] == target_image_version:\n        image_uuid = image['image_uuid']\n        print (\"image_uuid={}\".format(image_uuid))\n        exit(0)\n\nprint (\"Could not find image uuid for image version {}\".format(target_image_version))\nexit(1)\n#endregion make the api call","eval_variables":["image_uuid"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"KarbonUpgradeHosts","attrs":{"script":"# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1\/20220113\n# task_name:    KarbonUpgradeHosts\n# description:  Upgrades the target Karbon K8s cluster nodes to the desired host image version\n#               Using Karbon API: https:\/\/www.nutanix.dev\/api_references\/karbon\/#\/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   upgrade_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nkarbon_cluster_uuid = \"@@{karbon_cluster_uuid}@@\"\ncluster_name = \"@@{cluster_name}@@\"\nimage_uuid = \"@@{image_uuid}@@\"\ntarget_image_version = \"@@{target_image_version}@@\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout = 30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"\/api\/nutanix\/v3\/tasks\/{0}\".format(task_uuid)\n    url = \"https:\/\/{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                exit(1)\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare api call\nheaders = {'Content-Type': 'application\/json', 'Accept': 'application\/json'}\npayload = {\n    \"image_uuid\": image_uuid,\n    \"cluster_uuid\": karbon_cluster_uuid,\n    \"drain-policy\": \"kAlways\",\n    \"drain-timeout\": \"180s\"\n}\nmethod = 'POST'\nurl = \"https:\/\/{}:9440\/karbon\/acs\/k8s\/cluster\/{}\/upgrade\".format(\n    prism_central_ip,\n    karbon_cluster_uuid\n)\n#endregion prepare api call\n\n\n#region make api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Upgrading Kubernetes cluster {} to host image version {}\".format(cluster_name,target_image_version))\nprint(json.loads(resp.content))\nupgrade_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(upgrade_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,upgrade_task_uuid)\n\nexit(0)\n#endregion make api call","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"8ba06f44_runbook","main_task_local_reference":{"kind":"app_task","name":"70f463a2_dag"},"variable_list":[{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"cluster_name","value":"karbon-test-cluster","label":"Enter the name of the k8s cluster you want to upgrade","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"target_image_version","value":"ntnx-1.1","label":"Which host imageversion do you want to upgrade to?","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["ntnx-1.1","ntnx-1.0"]}},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"karbon_cluster_uuid","value":"","label":"","attrs":{"type":""},"editables":{"value":false},"is_hidden":true,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"image_uuid","value":"","label":"","attrs":{"type":""},"editables":{"value":false},"is_hidden":true,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"prism_central_ip","value":"10.48.108.12","label":"","attrs":{"type":""},"editables":{"value":false},"is_hidden":true,"options":{"type":"PREDEFINED","choices":[]}}]}},"name":"karbon-upgrade-image"},"api_version":"3.0","metadata":{"last_update_time":"1642089329507860","kind":"runbook","spec_version":5,"creation_time":"1642088374635652","name":"karbon-upgrade-image"}}